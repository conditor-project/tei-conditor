<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0" 
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns="http://www.tei-c.org/ns/1.0"
    exclude-result-prefixes="xs">  
	
<!--  ================================================================================
   C Stock, S. Gregorio, 2020-06. Dernière modification : 2021-08-27.    

Cette feuille de style traite les notices de thèses françaises issus de la bibliographie nationale des thèses dans leur version de soutenance signalés dans le Sudoc en format Unimarc version XMLlisée.
  
 Différences entre TEI0 et TEI1:
      - "abstract" : dans le nouveau modèle, il doit avoir un ou plusieurs fils éléments (p, list table). Dans l'ancien, valeur textuelle.
      - "idno" identifiant de la production : dans le nouveau modèle, fils de "analytic", dans l'ancien, fils de biblStruct (après monographic)
       Ce XSL utilise la version TEI0
      - idno analytic dans biblStruct
      - abstract sans fils
      
      Modification le 25/08/2020 :
         xmlns:tei="http://www.tei-c.org/ns/1.0" devient     xmlns="http://www.tei-c.org/ns/1.0"
      Modification 2 octobre 2020 :
      	<language> : générer le libellé en anglais et corrections code 2 caractères
      Modification 7 octobre 2020 :
      	<language> - ajout du code "la" pour "Latin" dans l'attribut
      Modifications le 27 octobre 2020 :
      -  Mots clés auteur : ajout de @xml:lang="und" pour "undetermined"
      -  Template "jury" : ajout de "702" (notices avant reforme)
      -  Template "institution" : ajout de 712 (notices avant reforme)
      
      Modifications le 27 août 2021 :
      - élément <ref @target> : ajout d'un "normalize-space" pour la valeur de l'attribut (URL) afin de supprimer les espaces en fin d'URL (erreurs saisi Sudoc). Ceci crée des soucis pour récupérer le fulltext des notices avec le programme de Dominique Bésagni.
      - type de thèse et domaine de thèse : 
      		Ajout d'un test sur le contenu de 328$b <xsl:when test="contains(./subfield[@code='b'], 'exercice')"> et génération de la chaîne "Thèse d'exercice" pour éviter les rejets liés à l'apostrophe
      		Ajout d'un test sur la présence de "Thèse d'exercice" en position 2 du champ répétitif 328 Unimarc pour éviter les rejets co-formatter si le type "Mémoire de DES" apparaît en premier
      
      Modifications du 27 septembre 2022 : D. Besagni, S. Gregorio
      - élément <idno type="nnt"> : 
      		la condition “string.length(.)=12” devient “string.length(.)&gt;=12” pour les cas où une mention (inutile) est ajoutée, du genre “ (thèse d’exercice)”
      		la commande “<xsl:apply-templates/>” est remplacée par “<xsl:value-of select="substring(.,1,12)"/>” qui garde les 12 premiers caractères.
=======================================================================================  -->
	
 <xsl:output encoding="UTF-8" indent="yes"/>
 
  <xsl:param name="DateAcqu"/>
  <xsl:param name="today"/> <!-- Date de création de la notice Conditor = date de transformation XSLT -->
    
<xsl:template match="record">
      <TEI> 
        <text>
          <body>
            <listBibl>
              <biblFull>
                         <!-- titleStmt obligatoire ; minimum : fils title.  -->
                <titleStmt>
                  <xsl:apply-templates select="datafield[@tag='200']/subfield[@code='a']"/>
				  <xsl:if test="datafield[@tag='200']/subfield[@code='e']/text()">
				  <xsl:apply-templates select="datafield[@tag='200']/subfield[@code='e']"/></xsl:if>
                  <xsl:apply-templates select="datafield[@tag='541']/subfield[@code='a']"/>
				  <xsl:if test="datafield[@tag='541']/subfield[@code='e']/text()">
				  <xsl:apply-templates select="datafield[@tag='541']/subfield[@code='e']"/></xsl:if>
                </titleStmt>
                <editionStmt>
                     <edition> 
                	<date type="whenDownloaded"><xsl:value-of select="$DateAcqu"/></date>
                     	<date type="whenCreated"><xsl:value-of select="$today"/></date>
                  </edition>
                	<respStmt>
                		<resp>Generated by TEI-Conditor XSLT (https://github.com/conditor/tei-conditor), from original Sudoc document ppn <xsl:value-of select="//controlfield[@tag='001']"/></resp>
                		<name>Conditor</name>
                	</respStmt>
                </editionStmt>
                <publicationStmt>
                   <distributor>Conditor</distributor> 
                </publicationStmt>
	<notesStmt>
		<note type="thesisOriginal" n="1">Version de soutenance</note>
	</notesStmt>
				
                <sourceDesc>
                  <biblStruct>
                    <analytic>
                  <xsl:apply-templates select="datafield[@tag='200']/subfield[@code='a']"/>
				  <xsl:if test="datafield[@tag='200']/subfield[@code='e']/text()">
				  <xsl:apply-templates select="datafield[@tag='200']/subfield[@code='e']"/></xsl:if>
                  <xsl:apply-templates select="datafield[@tag='541']/subfield[@code='a']"/>
				  <xsl:if test="datafield[@tag='541']/subfield[@code='e']/text()">
				  <xsl:apply-templates select="datafield[@tag='541']/subfield[@code='e']"/></xsl:if>
                      <xsl:apply-templates select="datafield[@tag='700']"/>
				<xsl:if test="datafield[@tag='701']/subfield[@code='4']='070'">
					<xsl:call-template name="coauthor"/></xsl:if> 
             </analytic>
                        
            <monogr>
            	            	
            	<!--ajout SG -->
            	<xsl:for-each select="datafield[@tag='701'] | datafield[@tag='702']">
            		<xsl:if test="subfield[@code='4']!='070'">
            			<xsl:call-template name="jury"/> 
            		</xsl:if>
            	</xsl:for-each>
            	
		<!-- Pour datafield[@tag='711'] -->
			<xsl:call-template name="institution"/>
		<imprint>
			<xsl:apply-templates select="datafield[@tag='328']/subfield[@code='d']"/>
			<xsl:apply-templates select="datafield[@tag='214']/subfield[@code='d']"/>
			<xsl:apply-templates select="datafield[@tag='215']/subfield[@code='a']"/>
		</imprint>
                    </monogr>
		<xsl:apply-templates select="datafield[@tag='029']/subfield[@code='b']"/>
		<xsl:apply-templates select="controlfield[@tag='001']"/>
		<xsl:call-template name="fulltext"/>
                  </biblStruct>
                </sourceDesc>
              	
                <profileDesc>
		<langUsage>
                 		 <xsl:apply-templates select="datafield[@tag='101']/subfield[@code='a']"/>
		</langUsage>
                	
                	<textClass>
                		<!-- mots-cles auteur  ;  indexation rameau et fmesh  -->
                	<xsl:for-each select="datafield[@tag='606']">
                		<xsl:if test="subfield[@code='2']='rameau'">
                			<xsl:call-template name="rameau"/>
                		</xsl:if>
                		<xsl:if test="subfield[@code='2']='fmesh'">
                			<xsl:call-template name="fmesh"/>
                		</xsl:if>  
                	</xsl:for-each>	
                	<xsl:apply-templates select="datafield[@tag='610']"/>
                		<!--  classifications TEF et dewey  -->
                	<xsl:apply-templates select="datafield[@tag='686']/subfield[@code='a']"/>
                	<xsl:apply-templates select="datafield[@tag='676']/subfield[@code='a']"/>	
                		
                		<!--  type et discipline de thèse  -->
                	<xsl:apply-templates select="datafield[@tag='328']"/>  
                	<xsl:apply-templates select="datafield[@tag='328']/subfield[@code='b']"/>  
		</textClass>
                	<!--  abstract  	<abstract xml:lang=""  --> 
                	<xsl:apply-templates select="datafield[@tag='330']"/> 
		</profileDesc>                       
	 </biblFull>
    </listBibl></body></text></TEI>
</xsl:template>
 
 <!--     BEGIN  TEMPLATES   -->
<!-- Titre(s) --> 
<xsl:template match="datafield[@tag='200']/subfield[@code='a']"> 
	<xsl:element name="title">
		<xsl:attribute name="xml:lang">
			<xsl:value-of select="substring(//datafield[@tag='101']/subfield[@code='a'],1,2)"/>
		</xsl:attribute>
		<xsl:apply-templates/>
	</xsl:element>
</xsl:template>

<xsl:template match="datafield[@tag='200']/subfield[@code='e']">
	<xsl:element name="title">		
		<xsl:attribute name="type">sub</xsl:attribute>
		<xsl:attribute name="xml:lang">
			<xsl:value-of select="substring(//datafield[@tag='101']/subfield[@code='a'],1,2)"/></xsl:attribute>
		<xsl:apply-templates/>
	  </xsl:element>
</xsl:template>

<xsl:template match="datafield[@tag='541']/subfield[@code='a']">
	<xsl:element name="title">
		<xsl:attribute name="xml:lang">
			<xsl:value-of select="substring(//subfield[@code='z'],1,2)"/>
		</xsl:attribute>
		<xsl:apply-templates/>
	</xsl:element>
</xsl:template>
<xsl:template match="datafield[@tag='541']/subfield[@code='e']">
	<xsl:element name="title">
		<xsl:attribute name="type">sub</xsl:attribute>
		<xsl:attribute name="xml:lang">
			<xsl:value-of select="substring(//subfield[@code='z'],1,2)"/>
		</xsl:attribute>		
		<xsl:apply-templates/>
	</xsl:element>
</xsl:template>

<!--  auteur -->
<xsl:template match="datafield[@tag='700']">
	<author role="aut">
		<persName>
			<forename>	   
				<xsl:value-of select="./subfield[@code='b']"/>
			</forename>
			<surname>
				<xsl:value-of select="./subfield[@code='a']"/>
			</surname>
		</persName>
        	<idno type="idRef">
        		<xsl:value-of select="./subfield[@code='3']"/>
	</idno>
	</author>
</xsl:template>  

<!-- co_auteur en 701  --> 
<xsl:template name="coauthor">
	<author role="aut">
		<persName>
			<forename>	   
				<xsl:value-of select="//datafield[@tag='701']/subfield[@code='b']"/>
			</forename>
			<surname>
				<xsl:value-of select="//datafield[@tag='701']/subfield[@code='a']"/>
			</surname>
		</persName>
        <idno type="idRef">
        	<xsl:value-of select="//datafield[@tag='701']/subfield[@code='3']"/>
		</idno>
	</author>
</xsl:template>  

<!--  Membres du jury  -->
<xsl:template name="jury">
	<xsl:element name="editor">
		<xsl:attribute name="role">
		<xsl:choose>
			<xsl:when test="./subfield[@code='4']='727'">
				<xsl:text>ths</xsl:text>	</xsl:when>
			<xsl:when test="./subfield[@code='4']='555'">
				<xsl:text>opn</xsl:text>	</xsl:when>
			<xsl:when test="./subfield[@code='4']='958'">
				<xsl:text>thr</xsl:text>	</xsl:when>
			<xsl:when test="./subfield[@code='4']='956'">
				<xsl:text>pra</xsl:text>	</xsl:when>
		</xsl:choose>
		</xsl:attribute>
		<persName>
			<forename>	   
				<xsl:value-of select="./subfield[@code='b']"/>
			</forename>
			<surname>
				<xsl:value-of select="./subfield[@code='a']"/>
			</surname>
		</persName>
       	 	<idno type="idRef">
        			<xsl:value-of select="./subfield[@code='3']"/>
		</idno>
	  </xsl:element>
</xsl:template>  
	
	<!--  Etablissement de soutenance, école doctorale, laboratoire d'accueil, etc  -->
<xsl:template name="institution">
	<xsl:for-each select="datafield[@tag='711'] | datafield[@tag='712']">
		<xsl:element name="editor">
		<xsl:attribute name="role">
		<xsl:choose>
			<xsl:when test="./subfield[@code='4']='295'">
				<xsl:text>dgg</xsl:text>	</xsl:when>
			<xsl:when test="./subfield[@code='4']='995'">
				<xsl:text>dcg</xsl:text>	</xsl:when>
			<xsl:when test="./subfield[@code='4']='996'">
				<xsl:text>dos</xsl:text>	</xsl:when>	
			<xsl:when test="./subfield[@code='4']='981'">
				<xsl:text>tal</xsl:text>	</xsl:when>
			<xsl:when test="./subfield[@code='4']='984'">
				<xsl:text>tar</xsl:text>	</xsl:when>
		</xsl:choose>
		</xsl:attribute>
		<orgName type="institution">
				<xsl:value-of select="./subfield[@code='a']"/>
		</orgName >	
		<xsl:if test="./subfield[@code='b']/text()">
			<orgName type="laboratory">
				<xsl:value-of select="./subfield[@code='b']"/>
			</orgName >
		</xsl:if>
       	 	<idno type="idRef">
        			<xsl:value-of select="./subfield[@code='3']"/>
		</idno>
	</xsl:element>
	</xsl:for-each>
</xsl:template>
	
<!-- bloc imprint  -->
<xsl:template match="datafield[@tag='328']/subfield[@code='d']">
  <xsl:if test="position()=1">
	<date type="dateDefended">
		<xsl:apply-templates/> 
	</date>
  </xsl:if>
</xsl:template>

<xsl:template match="datafield[@tag='214']/subfield[@code='d']">
	<date type="whenProduced">
		<xsl:apply-templates/>
	</date>
</xsl:template>
	
<xsl:template match="datafield[@tag='215']/subfield[@code='a']">
	<biblScope unit="pagesNo">
		<xsl:apply-templates/>
	</biblScope>
</xsl:template>

	<!-- bloc identifier -->
<xsl:template match="controlfield[@tag='001']">
	<idno type="ppnSudoc">
		<xsl:apply-templates/>
	</idno>
</xsl:template>

	<!-- nouveau contrôle : si le NNT contient moins de 12 positions, il est ignoré  (pour éviter les nnt tronqués type 2014ROUEM ou 2014POITMO  qui risqueraient de créer des faux doublons  -->
	<!-- utilisation de substring pour les cas où on a du texte après le NNT -->
<xsl:template match="datafield[@tag='029']/subfield[@code='b']">
	<xsl:if test="string-length(.)&gt;=12">
	<idno type="nnt">
		<xsl:value-of select="substring(.,1,12)"/>
	</idno>
	</xsl:if>
</xsl:template>

<!--  Language>  -->
<xsl:template match="datafield[@tag='101']/subfield[@code='a']">
	<xsl:element name="language">
		<xsl:attribute name="ident">
		     <xsl:choose>
		   	<xsl:when test="normalize-space(.)='chi' ">zh</xsl:when>
		   	<xsl:when test="normalize-space(.)='cze' ">cs</xsl:when>
		   	<xsl:when test="normalize-space(.)='ger' ">de</xsl:when>
		     	<xsl:when test="normalize-space(.)='gre' ">el</xsl:when>
		     	<xsl:when test="normalize-space(.)='lat' ">la</xsl:when>
			<xsl:when test="normalize-space(.)='pol' ">pl</xsl:when>
			<xsl:when test="normalize-space(.)='por' ">pt</xsl:when>
		     	<xsl:when test="normalize-space(.)='rum' ">ro</xsl:when>
		     	<xsl:when test="normalize-space(.)='spa' ">es</xsl:when>
		     	<xsl:when test="normalize-space(.)='rum' ">ro</xsl:when>
		   	<xsl:otherwise>
		   		<xsl:value-of select="substring(.,1,2)"/>
		   	</xsl:otherwise>
		     </xsl:choose>
		</xsl:attribute> 
		<!--<xsl:template match="Language"> -->
		<xsl:choose>
				<xsl:when test="normalize-space(.)='aar' ">Afar</xsl:when>
				<xsl:when test="normalize-space(.)='abk' ">Abkhazian</xsl:when>
				<xsl:when test="normalize-space(.)='afr' ">Afrikaans</xsl:when>
				<xsl:when test="normalize-space(.)='aka' ">Akan</xsl:when>
				<xsl:when test="normalize-space(.)='alb' ">Albanian</xsl:when>
				<xsl:when test="normalize-space(.)='amh' ">Amharic</xsl:when>
				<xsl:when test="normalize-space(.)='ara' ">Arabic</xsl:when>
				<xsl:when test="normalize-space(.)='arm' ">Armenian</xsl:when>
				<xsl:when test="normalize-space(.)='asm' ">Assamese</xsl:when>
				<xsl:when test="normalize-space(.)='ava' ">Avaric</xsl:when>
				<xsl:when test="normalize-space(.)='ave' ">Avestan</xsl:when>
				<xsl:when test="normalize-space(.)='aym' ">Aymara</xsl:when>
				<xsl:when test="normalize-space(.)='aze' ">Azerbajani</xsl:when>
				<xsl:when test="normalize-space(.)='bak' ">Bashkir</xsl:when>
				<xsl:when test="normalize-space(.)='bam' ">Bambara</xsl:when>
				<xsl:when test="normalize-space(.)='baq' ">Basque</xsl:when>
				<xsl:when test="normalize-space(.)='bel' ">Byelorussian</xsl:when>
				<xsl:when test="normalize-space(.)='ben' ">Bengali</xsl:when>
				<xsl:when test="normalize-space(.)='bre' ">Breton</xsl:when>
				<xsl:when test="normalize-space(.)='bul' ">Bulgarian</xsl:when>
				<xsl:when test="normalize-space(.)='bur' ">Burmese</xsl:when>
				<xsl:when test="normalize-space(.)='cat' ">Catalan</xsl:when>
				<xsl:when test="normalize-space(.)='che' ">Chechen</xsl:when>
				<xsl:when test="normalize-space(.)='chi' ">Chinese</xsl:when>
				<xsl:when test="normalize-space(.)='chu' ">Church slavic</xsl:when>
				<xsl:when test="normalize-space(.)='chv' ">Chuvash</xsl:when>
				<xsl:when test="normalize-space(.)='cor' ">Cornish</xsl:when>
				<xsl:when test="normalize-space(.)='cos' ">Corsican</xsl:when>
				<xsl:when test="normalize-space(.)='cre' ">Cree</xsl:when>
				<xsl:when test="normalize-space(.)='cze' ">Czech</xsl:when>
				<xsl:when test="normalize-space(.)='dan' ">Danish</xsl:when>
				<xsl:when test="normalize-space(.)='dut' ">Dutch</xsl:when>
				<xsl:when test="normalize-space(.)='eng' ">English</xsl:when>
				<xsl:when test="normalize-space(.)='epo' ">Esperanto</xsl:when>
				<xsl:when test="normalize-space(.)='est' ">Estonian</xsl:when>
				<xsl:when test="normalize-space(.)='ewe' ">Ewe</xsl:when>
				<xsl:when test="normalize-space(.)='fao' ">Faroese</xsl:when>
				<xsl:when test="normalize-space(.)='fin' ">Finnish</xsl:when>
				<xsl:when test="normalize-space(.)='fre' ">French</xsl:when>
				<xsl:when test="normalize-space(.)='ful' ">Fulah</xsl:when>
				<xsl:when test="normalize-space(.)='geo' ">Georgian</xsl:when>
				<xsl:when test="normalize-space(.)='ger' ">German</xsl:when>
				<xsl:when test="normalize-space(.)='glg' ">Galician</xsl:when>
				<xsl:when test="normalize-space(.)='gre' ">Greek, modern</xsl:when>
				<xsl:when test="normalize-space(.)='guj' ">Gujarati</xsl:when>
				<xsl:when test="normalize-space(.)='hau' ">Hausa</xsl:when>
				<xsl:when test="normalize-space(.)='heb' ">Hebrew</xsl:when>
				<xsl:when test="normalize-space(.)='her' ">Herero</xsl:when>
				<xsl:when test="normalize-space(.)='hin' ">Hindi</xsl:when>
				<xsl:when test="normalize-space(.)='hrv' ">Croatian</xsl:when>
				<xsl:when test="normalize-space(.)='hun' ">Hungarian</xsl:when>
				<xsl:when test="normalize-space(.)='ice' ">Icelandic</xsl:when>
				<xsl:when test="normalize-space(.)='ind' ">Indonesian</xsl:when>
				<xsl:when test="normalize-space(.)='ita' ">Italian</xsl:when>
				<xsl:when test="normalize-space(.)='jav' ">Javanese</xsl:when>
				<xsl:when test="normalize-space(.)='jpn' ">Japanese</xsl:when>
				<xsl:when test="normalize-space(.)='kan' ">Kannada</xsl:when>
				<xsl:when test="normalize-space(.)='kas' ">Kashmiri</xsl:when>
				<xsl:when test="normalize-space(.)='kau' ">Kanuri</xsl:when>
				<xsl:when test="normalize-space(.)='kaz' ">Kazakh</xsl:when>
				<xsl:when test="normalize-space(.)='kik' ">Kikuyu</xsl:when>
				<xsl:when test="normalize-space(.)='kin' ">Kinyarwanda</xsl:when>
				<xsl:when test="normalize-space(.)='kir' ">Kirghiz</xsl:when>
				<xsl:when test="normalize-space(.)='kon' ">Kongo</xsl:when>
				<xsl:when test="normalize-space(.)='kor' ">Korean</xsl:when>
				<xsl:when test="normalize-space(.)='kur' ">Kurdish</xsl:when>
				<xsl:when test="normalize-space(.)='lao' ">Lao</xsl:when>
				<xsl:when test="normalize-space(.)='lat' ">Latin</xsl:when>
				<xsl:when test="normalize-space(.)='lav' ">Latvian</xsl:when>
				<xsl:when test="normalize-space(.)='lit' ">Lithuanian</xsl:when>
				<xsl:when test="normalize-space(.)='lub' ">Luba-Katanga</xsl:when>
				<xsl:when test="normalize-space(.)='lug' ">Ganda</xsl:when>
				<xsl:when test="normalize-space(.)='mac' ">Macedonian</xsl:when>
				<xsl:when test="normalize-space(.)='mal' ">Malayalam</xsl:when>
				<xsl:when test="normalize-space(.)='mao' ">Maori</xsl:when>
				<xsl:when test="normalize-space(.)='mar' ">Marathi</xsl:when>
				<xsl:when test="normalize-space(.)='may' ">Malay</xsl:when>
				<xsl:when test="normalize-space(.)='mlg' ">Malagasy</xsl:when>
				<xsl:when test="normalize-space(.)='mlt' ">Maltese</xsl:when>
				<xsl:when test="normalize-space(.)='mon' ">Mongolian</xsl:when>
				<xsl:when test="normalize-space(.)='nav' ">Navajo</xsl:when>
				<xsl:when test="normalize-space(.)='nep' ">Nepali</xsl:when>
				<xsl:when test="normalize-space(.)='nor' ">Norwegian</xsl:when>
				<xsl:when test="normalize-space(.)='nya' ">Nyanja</xsl:when>
				<xsl:when test="normalize-space(.)='oci' ">Language d'Oc</xsl:when>
				<xsl:when test="normalize-space(.)='oji' ">Ojibwa</xsl:when>
				<xsl:when test="normalize-space(.)='ori' ">Oriya</xsl:when>
				<xsl:when test="normalize-space(.)='oss' ">Ossetic</xsl:when>
				<xsl:when test="normalize-space(.)='pan' ">Panjabi</xsl:when>
				<xsl:when test="normalize-space(.)='per' ">Persan, modern</xsl:when>
				<xsl:when test="normalize-space(.)='pli' ">Pali</xsl:when>
				<xsl:when test="normalize-space(.)='pol' ">Polish</xsl:when>
				<xsl:when test="normalize-space(.)='por' ">Portuguese</xsl:when>
				<xsl:when test="normalize-space(.)='pus' ">Pushto</xsl:when>
				<xsl:when test="normalize-space(.)='que' ">Quechua</xsl:when>
				<xsl:when test="normalize-space(.)='roh' ">Raeto-Romance </xsl:when>
				<xsl:when test="normalize-space(.)='rum' ">Romanian</xsl:when>
				<xsl:when test="normalize-space(.)='run' ">Rundi</xsl:when>
				<xsl:when test="normalize-space(.)='rus' ">Russian</xsl:when>
				<xsl:when test="normalize-space(.)='sag' ">Sango</xsl:when>
				<xsl:when test="normalize-space(.)='san' ">Sanskrit</xsl:when>
				<xsl:when test="normalize-space(.)='sin' ">Sinhala; sinhalese</xsl:when>
				<xsl:when test="normalize-space(.)='slo' ">Slovak</xsl:when>
				<xsl:when test="normalize-space(.)='slv' ">Slovenian</xsl:when>
				<xsl:when test="normalize-space(.)='snd' ">Sindhi</xsl:when>
				<xsl:when test="normalize-space(.)='som' ">Somali</xsl:when>
				<xsl:when test="normalize-space(.)='spa' ">Spanish</xsl:when>
				<xsl:when test="normalize-space(.)='srp' ">Serbian</xsl:when>
				<xsl:when test="normalize-space(.)='sun' ">Sundanese</xsl:when>
				<xsl:when test="normalize-space(.)='swa' ">Swahili</xsl:when>
				<xsl:when test="normalize-space(.)='swe' ">Swedish</xsl:when>
				<xsl:when test="normalize-space(.)='tah' ">Tahitian</xsl:when>
				<xsl:when test="normalize-space(.)='tam' ">Tamil</xsl:when>
				<xsl:when test="normalize-space(.)='tel' ">Telugu</xsl:when>
				<xsl:when test="normalize-space(.)='tha' ">Thao</xsl:when>
				<xsl:when test="normalize-space(.)='tib' ">Tibetan</xsl:when>
				<xsl:when test="normalize-space(.)='bor' ">Tibetan</xsl:when>
				<xsl:when test="normalize-space(.)='tir' ">Tigrinya</xsl:when>
				<xsl:when test="normalize-space(.)='tuk' ">Turkmen</xsl:when>
				<xsl:when test="normalize-space(.)='tur' ">Turkish</xsl:when>
				<xsl:when test="normalize-space(.)='twi' ">Twi</xsl:when>
				<xsl:when test="normalize-space(.)='uig' ">Uighur</xsl:when>
				<xsl:when test="normalize-space(.)='ukr' ">Ukrainian</xsl:when>
				<xsl:when test="normalize-space(.)='urd' ">Urdu</xsl:when>
				<xsl:when test="normalize-space(.)='uzb' ">Uzbek</xsl:when>
				<xsl:when test="normalize-space(.)='vie' ">Vietnamese</xsl:when>
				<xsl:when test="normalize-space(.)='wel' ">Welsh</xsl:when>
				<xsl:when test="normalize-space(.)='wol' ">Wolof</xsl:when>
				<xsl:when test="normalize-space(.)='xho' ">Xhosa</xsl:when>
				<xsl:when test="normalize-space(.)='yid' ">Yiddish</xsl:when>
				<xsl:when test="normalize-space(.)='yor' ">Yiddish</xsl:when>
				<xsl:when test="normalize-space(.)='zul' ">Zulu</xsl:when>
				<!-- à completer -->
				<xsl:otherwise>
					<xsl:text>English</xsl:text>
				</xsl:otherwise>
			</xsl:choose>   
	</xsl:element>
</xsl:template>


	
	<!--  link to fulltext  -->
<xsl:template name="fulltext">
	<xsl:if test="datafield[@tag='856']/subfield[@code='q']='PDF'">
		<ref type="file" n="1">
			<xsl:attribute name="target">
				<xsl:value-of select="normalize-space(datafield[@tag='856']/subfield[@code='u'])"/>
			</xsl:attribute>
		</ref>
	</xsl:if>
</xsl:template>

	<!--  KEYWORDS  -->
	
	<!-- Ajout SG -->
<xsl:template name="rameau">
	<keywords scheme="rameau">
		<term xml:lang="fr" type="topicalName" ref="https://www.idref.fr/{subfield[@code='a']/preceding-sibling::subfield[@code='3'][1]}">
			<term>
				<xsl:value-of select="subfield[@code='a']"/>
			</term>
			<xsl:if test="subfield[@code='a']/preceding-sibling::subfield[@code='3'][1]">
				<idno type="idRef">
					<xsl:value-of select="subfield[@code='a']/preceding-sibling::subfield[@code='3'][1]"/>
				</idno>
			</xsl:if>
		</term>
			
	<!-- plutôt utiliser des if au lieu de "choose" -->
		<xsl:if test="subfield[@code='x']">
			<term xml:lang="fr" type="subdivisionTopic" ref="https://www.idref.fr/{subfield[@code='x']/preceding-sibling::subfield[@code='3'][1]}">
				<term>
					<xsl:value-of select="subfield[@code='x']"/>
				</term>
				<xsl:if test="subfield[@code='x']/preceding-sibling::subfield[@code='3'][1]">
					<idno type="idRef">
						<xsl:value-of select="subfield[@code='x']/preceding-sibling::subfield[@code='3'][1]"/>
					</idno>
				</xsl:if>
			</term>	
		</xsl:if>
		<xsl:if test="subfield[@code='y']">
			<term xml:lang="fr" type="subdivisionGeo" ref="https://www.idref.fr/{subfield[@code='y']/preceding-sibling::subfield[@code='3'][1]}">
				<term>
					<xsl:value-of select="subfield[@code='y']"/>
				</term>
				<xsl:if test="subfield[@code='y']/preceding-sibling::subfield[@code='3'][1]">
					<idno type="idRef">
						<xsl:value-of select="subfield[@code='y']/preceding-sibling::subfield[@code='3'][1]"/>
					</idno>
				</xsl:if>
			</term>		
		</xsl:if>
		<xsl:if test="subfield[@code='z']">
			<term xml:lang="fr" type="subdivisionChrono" ref="https://www.idref.fr/{subfield[@code='z']/preceding-sibling::subfield[@code='3'][1]}">
				<term>
					<xsl:value-of select="subfield[@code='z']"/>
				</term>
				<xsl:if test="subfield[@code='z']/preceding-sibling::subfield[@code='3'][1]">
					<idno type="idRef">
						<xsl:value-of select="subfield[@code='z']/preceding-sibling::subfield[@code='3'][1]"/>
					</idno>
				</xsl:if>
			</term>		
		</xsl:if>
	</keywords>
</xsl:template>
<xsl:template name="fmesh">
	<keywords scheme="fmesh">
		<term xml:lang="fr" type="topicalName" ref="https://www.idref.fr/{subfield[@code='a']/preceding-sibling::subfield[@code='3'][1]}">
			<term>
				<xsl:value-of select="subfield[@code='a']"/>
			</term>
			<xsl:if test="subfield[@code='a']/preceding-sibling::subfield[@code='3'][1]">
				<idno type="idRef">
					<xsl:value-of select="subfield[@code='a']/preceding-sibling::subfield[@code='3'][1]"/>
				</idno>
			</xsl:if>
		</term>
		<!-- plutôt utiliser des if au lieu de "choose" -->
		<xsl:if test="subfield[@code='x']">
			<term xml:lang="fr" type="subdivisionTopic" ref="https://www.idref.fr/{subfield[@code='x']/preceding-sibling::subfield[@code='3'][1]}">
				<term>
					<xsl:value-of select="subfield[@code='x']"/>
				</term>
				<xsl:if test="subfield[@code='x']/preceding-sibling::subfield[@code='3'][1]">
					<idno type="idRef">
						<xsl:value-of select="subfield[@code='x']/preceding-sibling::subfield[@code='3'][1]"/>
					</idno>
				</xsl:if>
			</term>	
		</xsl:if>
		<xsl:if test="subfield[@code='y']">
			<term xml:lang="fr" type="subdivisionGeo" ref="https://www.idref.fr/{subfield[@code='y']/preceding-sibling::subfield[@code='3'][1]}">
				<term>
					<xsl:value-of select="subfield[@code='y']"/>
				</term>
				<xsl:if test="subfield[@code='y']/preceding-sibling::subfield[@code='3'][1]">
					<idno type="idRef">
						<xsl:value-of select="subfield[@code='y']/preceding-sibling::subfield[@code='3'][1]"/>
					</idno>
				</xsl:if>
			</term>		
		</xsl:if>
		<xsl:if test="subfield[@code='z']">
			<term xml:lang="fr" type="subdivisionChrono" ref="https://www.idref.fr/{subfield[@code='z']/preceding-sibling::subfield[@code='3'][1]}">
				<term>
					<xsl:value-of select="subfield[@code='z']"/>
				</term>
				<xsl:if test="subfield[@code='z']/preceding-sibling::subfield[@code='3'][1]">
					<idno type="idRef">
						<xsl:value-of select="subfield[@code='z']/preceding-sibling::subfield[@code='3'][1]"/>
					</idno>
				</xsl:if>
			</term>		
		</xsl:if>
	</keywords>
</xsl:template>

<!-- mots-clés auteur  -->
<xsl:template match="datafield[@tag='610']">
	<xsl:for-each select="./subfield[@code='a']">
		<keywords scheme="author">
			<term xml:lang="und">
				<xsl:apply-templates/>
			</term>
		</keywords>
	</xsl:for-each>
</xsl:template>

	<!--  classifications type TEF et Dewey  -->
<xsl:template match="datafield[@tag='686']/subfield[@code='a']">
	<classCode scheme="TEF">
		<xsl:apply-templates/>
	</classCode>
</xsl:template>
	
<xsl:template match="datafield[@tag='676']/subfield[@code='a']">
	<classCode scheme="Dewey">
		<xsl:apply-templates/>
	</classCode>
</xsl:template>
	
	<!--  Domaine scientifique de thèse  et type de thèse -->
<xsl:template match="datafield[@tag='328']">
	<xsl:choose>
		<xsl:when test="contains(./subfield[@code='b'], 'exercice')">
			<classCode scheme="thesisDomain">
				<xsl:value-of select="subfield[@code='b']/following-sibling::subfield[@code='c'][1]"/>
			</classCode>
		</xsl:when>
		<xsl:when test="contains(./subfield[@code='b'], 'doctorat')">
			<xsl:if test="position()=1">
				<classCode scheme="thesisDomain">
					<xsl:value-of select="subfield[@code='b']/following-sibling::subfield[@code='c'][1]"/>
				</classCode>
			</xsl:if>
		</xsl:when>
		<xsl:otherwise/>
	</xsl:choose>
</xsl:template>
	
<xsl:template match="datafield[@tag='328']/subfield[@code='b']">
	<xsl:choose>
		<xsl:when test="contains(., 'exercice')">
			<classCode scheme="typology">Thèse d'exercice</classCode>
		</xsl:when>
		<xsl:when test="contains(., 'doctorat')">
			<xsl:if test="position()=1">
				<classCode scheme="typology">
					<xsl:apply-templates/>
			</classCode>
		</xsl:if>
		</xsl:when>
	<xsl:otherwise/>
	</xsl:choose>
</xsl:template>
	
<!--   ABSTRACT  -->
<xsl:template match="datafield[@tag='330']">
	<xsl:choose>
		<xsl:when test="position()=1">
			<abstract xml:lang="fr">
				<xsl:value-of select="./subfield[@code='a']"/>
			</abstract>
		</xsl:when>
		<xsl:otherwise>
			<xsl:element name="abstract">
			<xsl:attribute name="xml:lang">
				<xsl:value-of select="substring(//datafield[@tag='101']/subfield[@code='d'][2],1,2)"/>
			</xsl:attribute>
				<xsl:value-of select="./subfield[@code='a']"/>
			</xsl:element>
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>
                		
</xsl:stylesheet>