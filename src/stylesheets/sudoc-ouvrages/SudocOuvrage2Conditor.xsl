<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0" 
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema" 
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns="http://www.tei-c.org/ns/1.0" 
    exclude-result-prefixes="xs">  
 
<!--  ================================================================================
   C Stock, S. Gregorio, 2020-10. Dernière modification : 29_10-2020.    
   
Cette feuille de style traite les notices d'ouvrages signalées dans le Sudoc en format Unimarc version XMLlisée.

  Elle utilise la version TEI0  dérivée de HAL :
      - idno analytic dans biblStruct
      - abstract sans fils
      
		mention d'édition  champ TEI  <EDITION> DANS BLOC <MONOGR> ,???????, sinon dans <editionStmt> - double sens  
	
==========================================================================================================  -->	
	
<xsl:output encoding="UTF-8" indent="yes"/>
<xsl:param name="DateAcqu"/>
<xsl:param name="today"/> <!-- Date de création de la notice Conditor = transformation XSLT -->
	
<xsl:template match="record">
      <TEI> 
        <text>
          <body>
            <listBibl>
              <biblFull>
                         <!-- titleStmt obligatoire ; minimum : fils title.  -->
                <titleStmt>
                  <xsl:apply-templates select="datafield[@tag='200']/subfield[@code='a']"/>
				  <xsl:if test="datafield[@tag='200']/subfield[@code='e']/text()">
				  <xsl:apply-templates select="datafield[@tag='200']/subfield[@code='e']"/></xsl:if>
                  <xsl:apply-templates select="datafield[@tag='541']/subfield[@code='a']"/>
				  <xsl:if test="datafield[@tag='541']/subfield[@code='e']/text()">
				  <xsl:apply-templates select="datafield[@tag='541']/subfield[@code='e']"/></xsl:if>
                </titleStmt>
                <editionStmt>
                  <edition>
                  	<date type="whenDownloaded"> <xsl:value-of select="$DateAcqu"/></date>
                  	<date type="whenCreated"><xsl:value-of select="$today"/></date> <!--  pas de transfo  -->
                  </edition>
                  <respStmt>
                  	<resp>Generated by TEI-Conditor XSLT (https://github.com/conditor/tei-conditor), from original Sudoc document ppn <xsl:value-of select="//controlfield[@tag='001']"/></resp>
                	<name>Conditor</name>
                  </respStmt>
                </editionStmt>
                <publicationStmt>
                   <distributor>Conditor</distributor> 
                </publicationStmt>
<!--	<notesStmt>
		<note type="thesisOriginal" n="1">Version de soutenance</note>
	</notesStmt>  -->
				
                <sourceDesc>
                  <biblStruct>
                    <analytic>
                 	 <xsl:apply-templates select="datafield[@tag='200']/subfield[@code='a']"/>
			 <xsl:if test="datafield[@tag='200']/subfield[@code='e']/text()">
			  <xsl:apply-templates select="datafield[@tag='200']/subfield[@code='e']"/></xsl:if>
               	 <xsl:apply-templates select="datafield[@tag='541']/subfield[@code='a']"/>
			  <xsl:if test="datafield[@tag='541']/subfield[@code='e']/text()">
			  <xsl:apply-templates select="datafield[@tag='541']/subfield[@code='e']"/></xsl:if>
                    	
                    		<xsl:if test="datafield[@tag='700']/subfield[@code='4']='070'">
                    			<xsl:apply-templates select="datafield[@tag='700']" mode="author"/>
                    		</xsl:if>
                    	<xsl:for-each select="datafield[@tag='701']">   <!--uniquement si valeur du subfield @code=4 = 070 -->
			<xsl:if test="subfield[@code='4']='070'">
				<xsl:call-template name="coauthor"/></xsl:if>
                    	</xsl:for-each>  
             </analytic>
                        
               <monogr>
            	<!--  uniquement si valeur du subfield @code=4 != 070  -->
                  		<!-- ajout SG -->
                	<xsl:if test="datafield[@tag='700']/subfield[@code='4']!='070'">
                		<xsl:apply-templates select="datafield[@tag='700']" mode="editor"/>
                  	</xsl:if>
               	
               	<xsl:for-each select="datafield[@tag='701'] | datafield[@tag='702']">
            		<xsl:if test="subfield[@code='4']!='070'">
            			<xsl:call-template name="editor"/> 
            		</xsl:if>
            	</xsl:for-each> 
            	
		<!--<xsl:apply-templates select="datafield[@tag='711']"/> -->
			<xsl:call-template name="institution"/>
            	
                  <!--  Collection/série  -->
                  	<xsl:apply-templates select="datafield[@tag='010']"/>
               	<xsl:apply-templates select="datafield[@tag='410'] | datafield[@tag='412']"/>
               	<xsl:if test="datafield[@tag='461']/subfield[@code='x']!=''">
               		<xsl:apply-templates select="datafield[@tag='461']"/>
               	</xsl:if>
               	
            	<imprint>
			<xsl:apply-templates select="datafield[@tag='328']/subfield[@code='d']"/>
		<!--pour les champs ci-dessous (facultatifs), faut-il faire le test de présence/absence ici ou dans le template ? -->
            		<xsl:apply-templates select="datafield[@tag='210'] | datafield[@tag='214']"/>
            		<xsl:apply-templates select="datafield[@tag='410']/subfield[@code='v'] | datafield[@tag='412']/subfield[@code='v']"/>
			<xsl:apply-templates select="datafield[@tag='215']/subfield[@code='a']"/>
		</imprint>
                    </monogr>
	<!--	<xsl:apply-templates select="datafield[@tag='029']/subfield[@code='b']"/>	-->
		<xsl:apply-templates select="controlfield[@tag='001']"/>
		<xsl:call-template name="fulltext"/>
                  </biblStruct>
                </sourceDesc>
              	
                <profileDesc>
		<langUsage>
                 		 <xsl:apply-templates select="datafield[@tag='101']/subfield[@code='a']"/>
		</langUsage>
                	
                	<textClass>
                		<!-- mots-cles auteur  ;  indexation rameau et fmesh  -->
                	<xsl:for-each select="datafield[@tag='606']">
                		<xsl:if test="subfield[@code='2']='rameau'">
                			<xsl:call-template name="rameau"/>
                		</xsl:if>
                		<xsl:if test="subfield[@code='2']='fmesh'">
                			<xsl:call-template name="fmesh"/>
                		</xsl:if>  
                	</xsl:for-each>
                		
                	<xsl:apply-templates select="datafield[@tag='610']"/>
                		
                		<!--  classifications Dewey et TEF -->
                	<xsl:apply-templates select="datafield[@tag='676']/subfield[@code='a']"/>
                		<!-- Test sur TEF  -->	
                	<xsl:for-each select="datafield[@tag='686']">   
                			<xsl:if test="subfield[@code='2']='TEF'">
                				<xsl:apply-templates select="datafield[@tag='686']/subfield[@code='a']"/>
                			</xsl:if>
                	</xsl:for-each>  
                		<!--  type et discipline de thèse  -->
                	<xsl:apply-templates select="datafield[@tag='328']/subfield[@code='c']"/>
                	<xsl:apply-templates select="datafield[@tag='328']/subfield[@code='b']"/>
                	<xsl:call-template name="docType"/>
                		
    		</textClass>
                	<!--  abstract  	<abstract xml:lang=""  --> 
                	<xsl:apply-templates select="datafield[@tag='330']"/> 
	       </profileDesc>                       
	 </biblFull>
    </listBibl></body></text></TEI>
</xsl:template>
 
 <!--     BEGIN  TEMPLATES   -->
<!-- Titre(s) --> 
<xsl:template match="datafield[@tag='200']/subfield[@code='a']"> 
	<xsl:element name="title">
	<xsl:attribute name="xml:lang">
		<xsl:value-of select="substring(//datafield[@tag='101']/subfield[@code='a'],1,2)"/>
			</xsl:attribute>
		<xsl:apply-templates/>
	</xsl:element>
</xsl:template>

<xsl:template match="datafield[@tag='200']/subfield[@code='e']">
		<xsl:element name="title">		
			<xsl:attribute name="type">sub</xsl:attribute>
			<xsl:attribute name="xml:lang">
				<xsl:value-of select="substring(//datafield[@tag='101']/subfield[@code='a'],1,2)"/></xsl:attribute>
		<xsl:apply-templates/>
	  </xsl:element>
</xsl:template>

<xsl:template match="datafield[@tag='541']/subfield[@code='a']">
	<xsl:element name="title">
		<xsl:attribute name="xml:lang">
			<xsl:value-of select="substring(//subfield[@code='z'],1,2)"/>
		</xsl:attribute>
		<xsl:apply-templates/>
	</xsl:element>
</xsl:template>
<xsl:template match="datafield[@tag='541']/subfield[@code='e']">
		<xsl:element name="title">
		<xsl:attribute name="type">sub</xsl:attribute>
		<xsl:attribute name="xml:lang">
			<xsl:value-of select="substring(//subfield[@code='z'],1,2)"/>
		</xsl:attribute>		
		<xsl:apply-templates/>
	</xsl:element>
</xsl:template>

<!--  Auteur -->
  
<xsl:template match="datafield[@tag='700']" mode="author">
	<author role="aut">
		<persName>
			<forename>	   
				<xsl:value-of select="./subfield[@code='b']"/>
			</forename>
			<surname>
				<xsl:value-of select="./subfield[@code='a']"/>
			</surname>
		</persName>
        <idno type="idRef">
        	<xsl:value-of select="./subfield[@code='3']"/>
		</idno>
	</author>
</xsl:template>  

<!-- co_auteur en 701  #### pb : multioccurrence avec le même rôle ; les occurrences sont bonnes, mais le nom est identique  --> 
<xsl:template name="coauthor">
	<xsl:for-each select=".">
	<author role="aut">
		<persName>
			<forename>	   
				<xsl:value-of select="./subfield[@code='b']"/>
			</forename>
			<surname>
				<xsl:value-of select="./subfield[@code='a']"/>
			</surname>
		</persName>
        <idno type="idRef">
        	<xsl:value-of select="./subfield[@code='3']"/>
		</idno>
	</author>
	</xsl:for-each>
</xsl:template>  

<xsl:template match="datafield[@tag='700']" mode="editor">
	<xsl:call-template name="editor"/> 
</xsl:template>
	
<xsl:template name="editor">
	<xsl:for-each select=".">
		<xsl:element name="editor">
		<xsl:attribute name="role">
		<xsl:choose>
			<xsl:when test="./subfield[@code='4']='340'">
				<xsl:text>edt</xsl:text>	</xsl:when>
			<xsl:when test="./subfield[@code='4']='651'">
				<xsl:text>pbd</xsl:text>	</xsl:when>
			<xsl:when test="./subfield[@code='4']='080'">
				<xsl:text>wpr</xsl:text>	</xsl:when>
			<xsl:when test="./subfield[@code='4']='180'">
				<xsl:text>ctg</xsl:text>	</xsl:when>
			<xsl:when test="./subfield[@code='4']='205'">
				<xsl:text>ctb</xsl:text>	</xsl:when>
			<xsl:when test="./subfield[@code='4']='280'">
				<xsl:text>dte</xsl:text>	</xsl:when>
			<xsl:when test="./subfield[@code='4']='300'">
				<xsl:text>drt</xsl:text>	</xsl:when>
			<xsl:when test="./subfield[@code='4']='600'">
				<xsl:text>pht</xsl:text>	</xsl:when>
			<xsl:when test="./subfield[@code='4']='710'">
				<xsl:text>sec</xsl:text>	</xsl:when>
			<xsl:when test="./subfield[@code='4']='730'">
				<xsl:text>trl</xsl:text>	</xsl:when>
			<xsl:when test="./subfield[@code='4']='727'">
				<xsl:text>ths</xsl:text>	</xsl:when>
			<xsl:when test="./subfield[@code='4']='555'">
				<xsl:text>opn</xsl:text>	</xsl:when>
			<xsl:when test="./subfield[@code='4']='582'">
				<xsl:text>pta</xsl:text>	</xsl:when>
			<xsl:when test="./subfield[@code='4']='584'">
				<xsl:text>inv</xsl:text>	</xsl:when>
			<xsl:when test="./subfield[@code='4']='587'">
				<xsl:text>pth</xsl:text>	</xsl:when>
			<xsl:when test="./subfield[@code='4']='695'">
				<xsl:text>sad</xsl:text>	</xsl:when>
			<xsl:when test="./subfield[@code='4']='958'">
				<xsl:text>thr</xsl:text>	</xsl:when>
			<xsl:when test="./subfield[@code='4']='956'">
				<xsl:text>pra</xsl:text>	</xsl:when>
			<xsl:otherwise>NEW ROLE</xsl:otherwise>
		</xsl:choose>
		</xsl:attribute>
		<persName>
			<forename>	   
				<xsl:value-of select="./subfield[@code='b']"/>
			</forename>
			<surname>
				<xsl:value-of select="./subfield[@code='a']"/>
			</surname>
		</persName>
  	      <idno type="idRef">
        		<xsl:value-of select="./subfield[@code='3']"/>
	       </idno>
	  </xsl:element>
	</xsl:for-each>
</xsl:template>  

<xsl:template name="institution">
	<xsl:for-each select="datafield[@tag='710'] | datafield[@tag='711'] | datafield[@tag='712']">
		<xsl:choose>
		  <xsl:when test=". /@ind1='0'">
		     <xsl:element name="editor">
		     <xsl:attribute name="role">
			<xsl:choose>
			<xsl:when test="./subfield[@code='4']='340'">
				<xsl:text>edt</xsl:text>	</xsl:when>
			<xsl:when test="./subfield[@code='4']='651'">
				<xsl:text>pbd</xsl:text>	</xsl:when>
			<xsl:when test="./subfield[@code='4']='557'">
				<xsl:text>orm</xsl:text>	</xsl:when>
			<xsl:when test="./subfield[@code='4']='475'">
				<xsl:text>isb</xsl:text>	</xsl:when>
			<xsl:when test="./subfield[@code='4']='582'">
				<xsl:text>pta</xsl:text>	</xsl:when>
			<xsl:when test="./subfield[@code='4']='587'">
				<xsl:text>pth</xsl:text>	</xsl:when>
			<xsl:when test="./subfield[@code='4']='723'">
				<xsl:text>spn</xsl:text>	</xsl:when>
			<xsl:when test="./subfield[@code='4']='295'">
				<xsl:text>dgg</xsl:text>	</xsl:when>
			<xsl:when test="./subfield[@code='4']='995'">
				<xsl:text>dcg</xsl:text>	</xsl:when>
			<xsl:when test="./subfield[@code='4']='996'">
				<xsl:text>dos</xsl:text>	</xsl:when>	
			<xsl:when test="./subfield[@code='4']='981'">
				<xsl:text>tal</xsl:text>	</xsl:when>
			<xsl:when test="./subfield[@code='4']='984'">
				<xsl:text>tar</xsl:text>	</xsl:when>
			<xsl:otherwise>NEW ROLE</xsl:otherwise>
			</xsl:choose>
		     </xsl:attribute>
		<orgName type="institution">
			<xsl:value-of select="./subfield[@code='a']"/>
		</orgName >	
			<xsl:if test="./subfield[@code='b']/text() and not (starts-with(subfield[@code='b'],'Colloq'))">
			<orgName type="laboratory">
				<xsl:value-of select="./subfield[@code='b']"/>
			</orgName >
		</xsl:if>	
		<xsl:if test="./subfield[@code='c']/text()">
			<settlement> 
				<xsl:value-of select="./subfield[@code='c']"/>
			</settlement>	
		</xsl:if>
        		<idno type="idRef">
        			<xsl:value-of select="./subfield[@code='3']"/>
		</idno>
		</xsl:element>
		</xsl:when>
		<xsl:when test=". /@ind1='1'">
		   <meeting>
		   	<title>
		   		<xsl:value-of select="./subfield[@code='a']"/>
		   	</title>
		   	<date type="start"> 
		   		<xsl:value-of select="./subfield[@code='f']"/>
		   	</date>
		   	<settlement>
		   		<xsl:value-of select="./subfield[@code='e']"/>	
		   	</settlement>
		</meeting></xsl:when>
	  </xsl:choose>
	</xsl:for-each>
</xsl:template>

<!--  Identifier ISBN  -->
<xsl:template match="datafield[@tag='010']">
	<xsl:choose>
		<xsl:when test="//datafield[@tag='135']/text()">
			<idno type="eisbn">
				<xsl:value-of select="./subfield[@code='a']"/>
			</idno>
		</xsl:when>
		<xsl:otherwise>
			<idno type="isbn">
				<xsl:value-of select="./subfield[@code='a']"/>
			</idno>
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>
		
<!-- Collection / série  et ISSN  -->
	<xsl:template match="datafield[@tag='410'] | datafield[@tag='412'] | datafield[@tag='461']">
	<title level="j">
		<xsl:value-of select="./subfield[@code='t']"/>
	</title>
	<xsl:if test="./subfield[@code='x']/text()">
	    <idno type="issn">
		<xsl:value-of select="./subfield[@code='x']"/> 
	    </idno>
	</xsl:if>
</xsl:template>
	
<!-- bloc imprint  -->
<xsl:template match="datafield[@tag='328']/subfield[@code='d']">
  <xsl:if test="position()=1">
	<date type="dateDefended">
		<xsl:apply-templates/> 
		<!--	 <xsl:value-of select="."/>  -->
	</date>
  </xsl:if>
</xsl:template>
	
	

<xsl:template match="datafield[@tag='210'] | datafield[@tag='214']">
	<xsl:for-each select="./subfield[@code='c']">
		<publisher>
			<xsl:apply-templates/>
		</publisher>
	</xsl:for-each>
	<pubPlace>
		<xsl:value-of select="./subfield[@code='a']"/>
	</pubPlace>
	<date type="datePub">
	    <xsl:choose>
		<xsl:when test="contains(./subfield[@code='d'],'DL')">
	    	<xsl:value-of select="substring-after(./subfield[@code='d'],'DL ')"/>
		</xsl:when>
	    	<xsl:when test="contains(./subfield[@code='d'],'C')">
	    		<xsl:value-of select="substring-after(./subfield[@code='d'],'C ')"/>
	    	</xsl:when>
	    	<xsl:when test="contains(./subfield[@code='d'],'P')">
	    		<xsl:value-of select="substring-after(./subfield[@code='d'],'P ')"/>
	    	</xsl:when>
	    	<xsl:otherwise>
	    		<xsl:value-of select="./subfield[@code='d']"/>
	    	</xsl:otherwise>
	    </xsl:choose>
	</date>
</xsl:template>



<!--  volume  -->
<xsl:template match="datafield[@tag='410']/subfield[@code='v'] | datafield[@tag='412']/subfield[@code='v']"> 
	<biblScope unit="volume">
		<xsl:apply-templates/>
	</biblScope>
</xsl:template>	
	
<xsl:template match="datafield[@tag='215']/subfield[@code='a']"> <!--  tester sur présence 135 cf clé USB  -->
	<biblScope unit="pagesNo">
		<xsl:apply-templates/>
	</biblScope>
</xsl:template>

<!-- bloc identifier -->
	
<xsl:template match="controlfield[@tag='001']">
	<idno type="ppnSudoc">
		<xsl:apply-templates/>
	</idno>
</xsl:template>

<xsl:template match="datafield[@tag='029']/subfield[@code='b']">
	<xsl:if test="string-length(.)=12">
	<idno type="nnt">
<!-- nouveau contrôle : si le NNT contient moins de 12 positions, il est ignoré  (pour éviter les nnt tronqués type 2014ROUEM ou 2014POITMO  qui risqueraient de créer des faux doublons  -->
		<xsl:apply-templates/>
	</idno>
	</xsl:if>
</xsl:template>

<!--  language  -->

	<xsl:template match="datafield[@tag='101']/subfield[@code='a']">
		<xsl:element name="language">
			<xsl:attribute name="ident">
				<xsl:choose>
					<xsl:when test="normalize-space(.)='chi' ">zh</xsl:when>
					<xsl:when test="normalize-space(.)='cze' ">cs</xsl:when>
					<xsl:when test="normalize-space(.)='ger' ">de</xsl:when>
					<xsl:when test="normalize-space(.)='gre' ">el</xsl:when>
					<xsl:when test="normalize-space(.)='lat' ">la</xsl:when>
					<xsl:when test="normalize-space(.)='pol' ">pl</xsl:when>
					<xsl:when test="normalize-space(.)='por' ">pt</xsl:when>
					<xsl:when test="normalize-space(.)='rum' ">ro</xsl:when>
					<xsl:when test="normalize-space(.)='spa' ">es</xsl:when>
					<xsl:when test="normalize-space(.)='rum' ">ro</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="substring(.,1,2)"/>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:attribute> 
			<!--<xsl:template match="Language"> -->
			<xsl:choose>
				<xsl:when test="normalize-space(.)='aar' ">Afar</xsl:when>
				<xsl:when test="normalize-space(.)='abk' ">Abkhazian</xsl:when>
				<xsl:when test="normalize-space(.)='afr' ">Afrikaans</xsl:when>
				<xsl:when test="normalize-space(.)='aka' ">Akan</xsl:when>
				<xsl:when test="normalize-space(.)='alb' ">Albanian</xsl:when>
				<xsl:when test="normalize-space(.)='amh' ">Amharic</xsl:when>
				<xsl:when test="normalize-space(.)='ara' ">Arabic</xsl:when>
				<xsl:when test="normalize-space(.)='arm' ">Armenian</xsl:when>
				<xsl:when test="normalize-space(.)='asm' ">Assamese</xsl:when>
				<xsl:when test="normalize-space(.)='ava' ">Avaric</xsl:when>
				<xsl:when test="normalize-space(.)='ave' ">Avestan</xsl:when>
				<xsl:when test="normalize-space(.)='aym' ">Aymara</xsl:when>
				<xsl:when test="normalize-space(.)='aze' ">Azerbajani</xsl:when>
				<xsl:when test="normalize-space(.)='bak' ">Bashkir</xsl:when>
				<xsl:when test="normalize-space(.)='bam' ">Bambara</xsl:when>
				<xsl:when test="normalize-space(.)='baq' ">Basque</xsl:when>
				<xsl:when test="normalize-space(.)='bel' ">Byelorussian</xsl:when>
				<xsl:when test="normalize-space(.)='ben' ">Bengali</xsl:when>
				<xsl:when test="normalize-space(.)='bre' ">Breton</xsl:when>
				<xsl:when test="normalize-space(.)='bul' ">Bulgarian</xsl:when>
				<xsl:when test="normalize-space(.)='bur' ">Burmese</xsl:when>
				<xsl:when test="normalize-space(.)='cat' ">Catalan</xsl:when>
				<xsl:when test="normalize-space(.)='che' ">Chechen</xsl:when>
				<xsl:when test="normalize-space(.)='chi' ">Chinese</xsl:when>
				<xsl:when test="normalize-space(.)='chu' ">Church slavic</xsl:when>
				<xsl:when test="normalize-space(.)='chv' ">Chuvash</xsl:when>
				<xsl:when test="normalize-space(.)='cor' ">Cornish</xsl:when>
				<xsl:when test="normalize-space(.)='cos' ">Corsican</xsl:when>
				<xsl:when test="normalize-space(.)='cre' ">Cree</xsl:when>
				<xsl:when test="normalize-space(.)='cze' ">Czech</xsl:when>
				<xsl:when test="normalize-space(.)='dan' ">Danish</xsl:when>
				<xsl:when test="normalize-space(.)='dut' ">Dutch</xsl:when>
				<xsl:when test="normalize-space(.)='eng' ">English</xsl:when>
				<xsl:when test="normalize-space(.)='epo' ">Esperanto</xsl:when>
				<xsl:when test="normalize-space(.)='est' ">Estonian</xsl:when>
				<xsl:when test="normalize-space(.)='ewe' ">Ewe</xsl:when>
				<xsl:when test="normalize-space(.)='fao' ">Faroese</xsl:when>
				<xsl:when test="normalize-space(.)='fin' ">Finnish</xsl:when>
				<xsl:when test="normalize-space(.)='fre' ">French</xsl:when>
				<xsl:when test="normalize-space(.)='ful' ">Fulah</xsl:when>
				<xsl:when test="normalize-space(.)='geo' ">Georgian</xsl:when>
				<xsl:when test="normalize-space(.)='ger' ">German</xsl:when>
				<xsl:when test="normalize-space(.)='glg' ">Galician</xsl:when>
				<xsl:when test="normalize-space(.)='gre' ">Greek, modern</xsl:when>
				<xsl:when test="normalize-space(.)='guj' ">Gujarati</xsl:when>
				<xsl:when test="normalize-space(.)='hau' ">Hausa</xsl:when>
				<xsl:when test="normalize-space(.)='heb' ">Hebrew</xsl:when>
				<xsl:when test="normalize-space(.)='her' ">Herero</xsl:when>
				<xsl:when test="normalize-space(.)='hin' ">Hindi</xsl:when>
				<xsl:when test="normalize-space(.)='hrv' ">Croatian</xsl:when>
				<xsl:when test="normalize-space(.)='hun' ">Hungarian</xsl:when>
				<xsl:when test="normalize-space(.)='ice' ">Icelandic</xsl:when>
				<xsl:when test="normalize-space(.)='ind' ">Indonesian</xsl:when>
				<xsl:when test="normalize-space(.)='ita' ">Italian</xsl:when>
				<xsl:when test="normalize-space(.)='jav' ">Javanese</xsl:when>
				<xsl:when test="normalize-space(.)='jpn' ">Japanese</xsl:when>
				<xsl:when test="normalize-space(.)='kan' ">Kannada</xsl:when>
				<xsl:when test="normalize-space(.)='kas' ">Kashmiri</xsl:when>
				<xsl:when test="normalize-space(.)='kau' ">Kanuri</xsl:when>
				<xsl:when test="normalize-space(.)='kaz' ">Kazakh</xsl:when>
				<xsl:when test="normalize-space(.)='kik' ">Kikuyu</xsl:when>
				<xsl:when test="normalize-space(.)='kin' ">Kinyarwanda</xsl:when>
				<xsl:when test="normalize-space(.)='kir' ">Kirghiz</xsl:when>
				<xsl:when test="normalize-space(.)='kon' ">Kongo</xsl:when>
				<xsl:when test="normalize-space(.)='kor' ">Korean</xsl:when>
				<xsl:when test="normalize-space(.)='kur' ">Kurdish</xsl:when>
				<xsl:when test="normalize-space(.)='lao' ">Lao</xsl:when>
				<xsl:when test="normalize-space(.)='lat' ">Latin</xsl:when>
				<xsl:when test="normalize-space(.)='lav' ">Latvian</xsl:when>
				<xsl:when test="normalize-space(.)='lit' ">Lithuanian</xsl:when>
				<xsl:when test="normalize-space(.)='lub' ">Luba-Katanga</xsl:when>
				<xsl:when test="normalize-space(.)='lug' ">Ganda</xsl:when>
				<xsl:when test="normalize-space(.)='mac' ">Macedonian</xsl:when>
				<xsl:when test="normalize-space(.)='mal' ">Malayalam</xsl:when>
				<xsl:when test="normalize-space(.)='mao' ">Maori</xsl:when>
				<xsl:when test="normalize-space(.)='mar' ">Marathi</xsl:when>
				<xsl:when test="normalize-space(.)='may' ">Malay</xsl:when>
				<xsl:when test="normalize-space(.)='mlg' ">Malagasy</xsl:when>
				<xsl:when test="normalize-space(.)='mlt' ">Maltese</xsl:when>
				<xsl:when test="normalize-space(.)='mon' ">Mongolian</xsl:when>
				<xsl:when test="normalize-space(.)='nav' ">Navajo</xsl:when>
				<xsl:when test="normalize-space(.)='nep' ">Nepali</xsl:when>
				<xsl:when test="normalize-space(.)='nor' ">Norwegian</xsl:when>
				<xsl:when test="normalize-space(.)='nya' ">Nyanja</xsl:when>
				<xsl:when test="normalize-space(.)='oci' ">Language d'Oc</xsl:when>
				<xsl:when test="normalize-space(.)='oji' ">Ojibwa</xsl:when>
				<xsl:when test="normalize-space(.)='ori' ">Oriya</xsl:when>
				<xsl:when test="normalize-space(.)='oss' ">Ossetic</xsl:when>
				<xsl:when test="normalize-space(.)='pan' ">Panjabi</xsl:when>
				<xsl:when test="normalize-space(.)='per' ">Persan, modern</xsl:when>
				<xsl:when test="normalize-space(.)='pli' ">Pali</xsl:when>
				<xsl:when test="normalize-space(.)='pol' ">Polish</xsl:when>
				<xsl:when test="normalize-space(.)='por' ">Portuguese</xsl:when>
				<xsl:when test="normalize-space(.)='pus' ">Pushto</xsl:when>
				<xsl:when test="normalize-space(.)='que' ">Quechua</xsl:when>
				<xsl:when test="normalize-space(.)='roh' ">Raeto-Romance </xsl:when>
				<xsl:when test="normalize-space(.)='rum' ">Romanian</xsl:when>
				<xsl:when test="normalize-space(.)='run' ">Rundi</xsl:when>
				<xsl:when test="normalize-space(.)='rus' ">Russian</xsl:when>
				<xsl:when test="normalize-space(.)='sag' ">Sango</xsl:when>
				<xsl:when test="normalize-space(.)='san' ">Sanskrit</xsl:when>
				<xsl:when test="normalize-space(.)='sin' ">Sinhala; sinhalese</xsl:when>
				<xsl:when test="normalize-space(.)='slo' ">Slovak</xsl:when>
				<xsl:when test="normalize-space(.)='slv' ">Slovenian</xsl:when>
				<xsl:when test="normalize-space(.)='snd' ">Sindhi</xsl:when>
				<xsl:when test="normalize-space(.)='som' ">Somali</xsl:when>
				<xsl:when test="normalize-space(.)='spa' ">Spanish</xsl:when>
				<xsl:when test="normalize-space(.)='srp' ">Serbian</xsl:when>
				<xsl:when test="normalize-space(.)='sun' ">Sundanese</xsl:when>
				<xsl:when test="normalize-space(.)='swa' ">Swahili</xsl:when>
				<xsl:when test="normalize-space(.)='swe' ">Swedish</xsl:when>
				<xsl:when test="normalize-space(.)='tah' ">Tahitian</xsl:when>
				<xsl:when test="normalize-space(.)='tam' ">Tamil</xsl:when>
				<xsl:when test="normalize-space(.)='tel' ">Telugu</xsl:when>
				<xsl:when test="normalize-space(.)='tha' ">Thao</xsl:when>
				<xsl:when test="normalize-space(.)='tib' ">Tibetan</xsl:when>
				<xsl:when test="normalize-space(.)='bor' ">Tibetan</xsl:when>
				<xsl:when test="normalize-space(.)='tir' ">Tigrinya</xsl:when>
				<xsl:when test="normalize-space(.)='tuk' ">Turkmen</xsl:when>
				<xsl:when test="normalize-space(.)='tur' ">Turkish</xsl:when>
				<xsl:when test="normalize-space(.)='twi' ">Twi</xsl:when>
				<xsl:when test="normalize-space(.)='uig' ">Uighur</xsl:when>
				<xsl:when test="normalize-space(.)='ukr' ">Ukrainian</xsl:when>
				<xsl:when test="normalize-space(.)='und' ">Undetermined</xsl:when>
				<xsl:when test="normalize-space(.)='urd' ">Urdu</xsl:when>
				<xsl:when test="normalize-space(.)='uzb' ">Uzbek</xsl:when>
				<xsl:when test="normalize-space(.)='vie' ">Vietnamese</xsl:when>
				<xsl:when test="normalize-space(.)='wel' ">Welsh</xsl:when>
				<xsl:when test="normalize-space(.)='wol' ">Wolof</xsl:when>
				<xsl:when test="normalize-space(.)='xho' ">Xhosa</xsl:when>
				<xsl:when test="normalize-space(.)='yid' ">Yiddish</xsl:when>
				<xsl:when test="normalize-space(.)='yor' ">Yiddish</xsl:when>
				<xsl:when test="normalize-space(.)='zul' ">Zulu</xsl:when>
				<!-- à completer -->
				<xsl:otherwise>
					<xsl:text>English</xsl:text>
				</xsl:otherwise>
			</xsl:choose>   
		</xsl:element>
	</xsl:template>
	
	<!--  link to fulltext  -->
<xsl:template name="fulltext">
	<xsl:if test="datafield[@tag='856']/subfield[@code='q']='PDF'">
		<ref type="file" n="1">
			<xsl:attribute name="target">
				<xsl:value-of select="datafield[@tag='856']/subfield[@code='u']"/>
			</xsl:attribute>
		</ref>
	</xsl:if>
</xsl:template>

		<!--  KEYWORDS et RAMEAU -->
	
	<!-- Ajout SG -->
	<xsl:template name="rameau">
		<keywords scheme="rameau">
			<term xml:lang="fr" type="topicalName" ref="https://www.idref.fr/{subfield[@code='a']/preceding-sibling::subfield[@code='3'][1]}">
				<term>
					<xsl:value-of select="subfield[@code='a']"/>
				</term>
				<xsl:if test="subfield[@code='a']/preceding-sibling::subfield[@code='3'][1]">
					<idno type="idRef">
						<xsl:value-of select="subfield[@code='a']/preceding-sibling::subfield[@code='3'][1]"/>
					</idno>
				</xsl:if>
			</term>
			
			<!-- plutôt utiliser des if au lieu de "choose" -->
			<xsl:if test="subfield[@code='x']">
				<term xml:lang="fr" type="subdivisionTopic" ref="https://www.idref.fr/{subfield[@code='x']/preceding-sibling::subfield[@code='3'][1]}">
					<term>
						<xsl:value-of select="subfield[@code='x']"/>
					</term>
					<xsl:if test="subfield[@code='x']/preceding-sibling::subfield[@code='3'][1]">
						<idno type="idRef">
							<xsl:value-of select="subfield[@code='x']/preceding-sibling::subfield[@code='3'][1]"/>
						</idno>
					</xsl:if>
				</term>	
			</xsl:if>
			<xsl:if test="subfield[@code='y']">
				<term xml:lang="fr" type="subdivisionGeo" ref="https://www.idref.fr/{subfield[@code='y']/preceding-sibling::subfield[@code='3'][1]}">
					<term>
						<xsl:value-of select="subfield[@code='y']"/>
					</term>
					<xsl:if test="subfield[@code='y']/preceding-sibling::subfield[@code='3'][1]">
						<idno type="idRef">
							<xsl:value-of select="subfield[@code='y']/preceding-sibling::subfield[@code='3'][1]"/>
						</idno>
					</xsl:if>
				</term>		
			</xsl:if>
			<xsl:if test="subfield[@code='z']">
				<term xml:lang="fr" type="subdivisionChrono" ref="https://www.idref.fr/{subfield[@code='z']/preceding-sibling::subfield[@code='3'][1]}">
					<term>
						<xsl:value-of select="subfield[@code='z']"/>
					</term>
					<xsl:if test="subfield[@code='z']/preceding-sibling::subfield[@code='3'][1]">
						<idno type="idRef">
							<xsl:value-of select="subfield[@code='z']/preceding-sibling::subfield[@code='3'][1]"/>
						</idno>
					</xsl:if>
				</term>		
			</xsl:if>
		</keywords>
	</xsl:template>
	<xsl:template name="fmesh">
		<keywords scheme="fmesh">
			<term xml:lang="fr" type="topicalName" ref="https://www.idref.fr/{subfield[@code='a']/preceding-sibling::subfield[@code='3'][1]}">
				<term>
					<xsl:value-of select="subfield[@code='a']"/>
				</term>
				<xsl:if test="subfield[@code='a']/preceding-sibling::subfield[@code='3'][1]">
					<idno type="idRef">
						<xsl:value-of select="subfield[@code='a']/preceding-sibling::subfield[@code='3'][1]"/>
					</idno>
				</xsl:if>
			</term>
			<!-- plutôt utiliser des if au lieu de "choose" -->
			<xsl:if test="subfield[@code='x']">
				<term xml:lang="fr" type="subdivisionTopic" ref="https://www.idref.fr/{subfield[@code='x']/preceding-sibling::subfield[@code='3'][1]}">
					<term>
						<xsl:value-of select="subfield[@code='x']"/>
					</term>
					<xsl:if test="subfield[@code='x']/preceding-sibling::subfield[@code='3'][1]">
						<idno type="idRef">
							<xsl:value-of select="subfield[@code='x']/preceding-sibling::subfield[@code='3'][1]"/>
						</idno>
					</xsl:if>
				</term>	
			</xsl:if>
			<xsl:if test="subfield[@code='y']">
				<term xml:lang="fr" type="subdivisionGeo" ref="https://www.idref.fr/{subfield[@code='y']/preceding-sibling::subfield[@code='3'][1]}">
					<term>
						<xsl:value-of select="subfield[@code='y']"/>
					</term>
					<xsl:if test="subfield[@code='y']/preceding-sibling::subfield[@code='3'][1]">
						<idno type="idRef">
							<xsl:value-of select="subfield[@code='y']/preceding-sibling::subfield[@code='3'][1]"/>
						</idno>
					</xsl:if>
				</term>		
			</xsl:if>
			<xsl:if test="subfield[@code='z']">
				<term xml:lang="fr" type="subdivisionChrono" ref="https://www.idref.fr/{subfield[@code='z']/preceding-sibling::subfield[@code='3'][1]}">
					<term>
						<xsl:value-of select="subfield[@code='z']"/>
					</term>
					<xsl:if test="subfield[@code='z']/preceding-sibling::subfield[@code='3'][1]">
						<idno type="idRef">
							<xsl:value-of select="subfield[@code='z']/preceding-sibling::subfield[@code='3'][1]"/>
						</idno>
					</xsl:if>
				</term>		
			</xsl:if>
		</keywords>
	</xsl:template>

	<!-- mots-clés auteur  -->		
<xsl:template match="datafield[@tag='610']">
		<xsl:for-each select="./subfield[@code='a']">
			<keywords scheme="author">
				<term xml:lang="und">
				<xsl:apply-templates/>
				</term>
			</keywords>
		</xsl:for-each>
</xsl:template>

	<!--  classifications type TEF et Dewey  -->
<xsl:template match="datafield[@tag='686']/subfield[@code='a']">
	<classCode scheme="TEF">
		<xsl:value-of select="."/>
	</classCode>
</xsl:template>
	
<xsl:template match="datafield[@tag='676']/subfield[@code='a']">
	<classCode scheme="Dewey">
		<xsl:apply-templates/>
	</classCode>
</xsl:template>
	
		<!--  Type et domaine scientifique de thèse  -->
<xsl:template match="datafield[@tag='328']/subfield[@code='c']">
	<xsl:if test="position()=1">
	<classCode scheme="thesisDomain">
		<xsl:apply-templates/>
	</classCode>
	</xsl:if>
</xsl:template>
	
	<xsl:template match="datafield[@tag='328']/subfield[@code='b']">
		<xsl:if test="position()=1">
	<classCode scheme="typology">
		<xsl:apply-templates/>
	</classCode>
	</xsl:if>
</xsl:template>

	<!--  test sur type d'ouvrage, cf. test pubmed book :  -->
	
<xsl:template name="docType">
	<xsl:choose>
	<!--	<xsl:when test="//datafield[@tag='608']/subfield[@code='a']='Catalogues d&apos;exposition'"> 
				<classCode scheme="typology">Catalogues d'exposition</classCode>
			</xsl:when>  -->
		<xsl:when test="datafield[@tag='608']/subfield[@code='a']='Mélanges et hommages'"> 
			<classCode scheme="typology">Mélanges et hommages</classCode>
		</xsl:when>
		<xsl:when test="datafield[@tag='608']/subfield[@code='a']='Actes de congrès'"> 
			<classCode scheme="typology">Actes de congrès</classCode>
		</xsl:when>
		<xsl:when test="datafield[@tag='608']/subfield[@code='a']='Biographies'"> 
			<classCode scheme="typology">Biographies</classCode>
		</xsl:when>
		<xsl:otherwise> <classCode scheme="typology">Monographie</classCode></xsl:otherwise>
	</xsl:choose>
</xsl:template>
	
<!--   ABSTRACT  -->
<xsl:template match="datafield[@tag='330']">
	<xsl:choose>
		<xsl:when test="position()=1">
			<abstract xml:lang="fr">
				<xsl:value-of select="./subfield[@code='a']"/>
			</abstract>
		</xsl:when>
		<xsl:otherwise>
			<xsl:element name="abstract">
			<xsl:attribute name="xml:lang">
				<xsl:value-of select="substring(//datafield[@tag='101']/subfield[@code='d'][2],1,2)"/>
			</xsl:attribute>
				<xsl:apply-templates/>
			</xsl:element>
		</xsl:otherwise>
	</xsl:choose>
  </xsl:template>
	
</xsl:stylesheet>